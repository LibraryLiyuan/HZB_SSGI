// [SSGIDenoiser.usf] - 基于 GAMES202 课程思路实现的联合双边滤波 (Joint Bilateral Filter)
// -----------------------------------------------------------------------------
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// [输入纹理]
// -----------------------------------------------------------------------------
// SSGI 原始输入：上一阶段 (Trace Pass) 生成的充满噪点的光照结果
Texture2D SSGIInputTexture; 

// 场景深度：用于计算深度权重 (D_Plane)，防止跨越前后物体的边缘进行模糊
Texture2D SceneDepthTexture; 

// GBuffer A：通常存储世界法线 (World Normal)。用于计算法线权重 (D_Normal)，防止跨越几何棱角模糊
Texture2D GBufferATexture;

// -----------------------------------------------------------------------------
// [输出]
// -----------------------------------------------------------------------------
// 降噪后的结果输出
RWTexture2D<float4> SSGIDenoiseOutput;

// -----------------------------------------------------------------------------
// [参数] 由 C++ 端传入
// -----------------------------------------------------------------------------
// 视口尺寸信息 (xy=Width/Height, zw=InvWidth/InvHeight)
float4 ViewSizeAndInvSize;

// 全局缓冲尺寸信息 (用于正确采样 GBuffer)
float4 BufferSizeAndInvSize; 

// 视口在全局缓冲中的左上角偏移 (解决编辑器 Viewport UV 错位问题)
float4 ViewRectMin;

// SSGI 强度倍率 (用于自适应调整颜色权重的 Sigma)
float Intensity;

// -----------------------------------------------------------------------------
// [辅助函数]
// -----------------------------------------------------------------------------

// 从 GBuffer 解码世界法线
// UE5 使用八面体压缩 (Octahedral Encoding) 将法线存储在 2 个通道中
float3 GetWorldNormal(float2 BufferUV)
{
    // GBufferA 的前两个通道存储压缩的法线
    float2 Oct = GBufferATexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).xy;
    
    // 解码算法 (Octahedral Decode)
    Oct = Oct * 2.0 - 1.0;
    float3 N = float3(Oct, 1.0 - dot(1.0, abs(Oct)));
    if (N.z < 0)
    {
        float2 SignNotZero = float2(N.x >= 0 ? 1.0 : -1.0, N.y >= 0 ? 1.0 : -1.0);
        N.xy = (1.0 - abs(N.yx)) * SignNotZero;
    }
    return normalize(N);
}

// 获取线性深度 (单位：厘米)
// SceneDepthTexture 存储的是 DeviceZ (非线性)，需要转换才能进行物理距离比较
float GetLinearDepth(float2 BufferUV)
{
    float DeviceZ = SceneDepthTexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).r;
    // ConvertFromDeviceZ 是 UE Common.ush 提供的内置函数
    return ConvertFromDeviceZ(DeviceZ);
}

// 计算两个颜色向量的距离平方 (Squared Euclidean Distance)
float SqrDistance(float3 A, float3 B)
{
    float3 Diff = A - B;
    return dot(Diff, Diff);
}

// 安全的反余弦函数 (防止浮点误差导致输入超出 [-1, 1] 范围返回 NaN)
float SafeAcos(float x)
{
    return acos(clamp(x, -1.0, 1.0));
}

// 计算亮度 (Luminance) - 用于萤火虫抑制
float LuminanceDenoise(float3 Color) { return dot(Color, float3(0.2126, 0.7152, 0.0722)); }

// -----------------------------------------------------------------------------
// [Compute Shader 主函数]
// -----------------------------------------------------------------------------
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void DenoiserCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    uint2 PixelPos = DispatchThreadID.xy;

    // 越界检查：如果当前线程超出了视口范围，直接退出
    if (any(PixelPos >= uint2(ViewSizeAndInvSize.xy))) return;
    
    // -------------------------------------------------------------------------
    // 1. 坐标系计算 (View Space vs Buffer Space)
    // -------------------------------------------------------------------------
    
    // Local UV: 对应当前 Viewport 的 UV (0~1)，用于采样 SSGIInputTexture (因为它也是 Viewport 大小)
    float2 LocalUV = (float2(PixelPos) + 0.5) * ViewSizeAndInvSize.zw;

    // Global UV: 对应整个 RenderTarget 的 UV，用于采样 SceneDepth 和 GBuffer (它们是全屏大小)
    // 必须加上 ViewRectMin 偏移
    float2 GlobalPixelPos = float2(PixelPos) + ViewRectMin.xy;
    float2 GlobalUV = (GlobalPixelPos + 0.5) * BufferSizeAndInvSize.zw;

    // -------------------------------------------------------------------------
    // 2. 获取中心像素数据 (Kernel Center)
    // -------------------------------------------------------------------------
    float3 CenterColor = SSGIInputTexture.SampleLevel(GlobalPointClampedSampler, LocalUV, 0).rgb;
    float3 CenterNormal = GetWorldNormal(GlobalUV);
    float CenterDepth = GetLinearDepth(GlobalUV);
    
    // -------------------------------------------------------------------------
    // 3. 准备滤波参数 (Sigma)
    // -------------------------------------------------------------------------
    
    // SigmaColor: 颜色差异容忍度。差异超过这个值，权重会急剧下降。
    float BaseSigmaColor = 0.8;
    
    // [自适应 Sigma]
    // 这是一个关键优化。如果 Intensity 很大 (比如 5.0)，颜色值会被整体放大。
    // 原本 0.1 的差异变成了 0.5。如果不放大 Sigma，滤波器会误认为这是巨大的边缘而停止模糊，导致噪点残留。
    // 所以 Sigma 必须随 Intensity 线性缩放。
    float AdaptiveSigmaColor = BaseSigmaColor * max(1.0, Intensity);

    float SigmaCoord = 32.0; // 空间距离权重：越远权重越低
    float SigmaNormal = 0.3; // 法线差异权重：约等于 17 度 (acos(1-0.3^2/2)?? 近似值)
    float SigmaPlane = 10.0; // 深度差异权重：10cm。超过这个深度差被视为不同物体。
    
    // 稍微给大一点，防止过度平滑导致斑驳 (Splotchy)
    // 这里并没有修改逻辑，保留了原始代码中的注释含义

    float3 SumColor = 0;
    float TotalWeight = 0;

    // -------------------------------------------------------------------------
    // 4. 执行滤波循环 (Kernel Loop)
    // -------------------------------------------------------------------------
    // 半径为 4，即 9x9 的窗口。对于实时渲染来说这算比较大的核，但为了平滑 1 SPP 的噪点是必要的。
    const int Radius = 4;
    
    for (int x = -Radius; x <= Radius; x++)
    {
        for (int y = -Radius; y <= Radius; y++)
        {
            // 计算邻居像素的 UV
            float2 NeighborLocalUV = LocalUV + float2(x, y) * ViewSizeAndInvSize.zw;
            
            // [核心注意] 邻居采样 GBuffer 时也要用 Global UV
            float2 NeighborGlobalUV = GlobalUV + float2(x, y) * BufferSizeAndInvSize.zw;

            // UV 边界检查
            if (any(NeighborLocalUV < 0.0) || any(NeighborLocalUV > 1.0)) continue;

            // 采样邻居数据
            float3 NeighborColor = SSGIInputTexture.SampleLevel(GlobalPointClampedSampler, NeighborLocalUV, 0).rgb;
            float3 NeighborNormal = GetWorldNormal(NeighborGlobalUV);
            float NeighborDepth = GetLinearDepth(NeighborGlobalUV);

            // -----------------------------------------------------------------
            // 5. 计算四重权重 (Joint Bilateral Weights)
            // 公式: Weight = exp( -Distance^2 / (2 * Sigma^2) )
            // -----------------------------------------------------------------

            // A. 空间权重 (Spatial Weight) - 距离中心越近，权重越大
            float Dist2 = float(x*x + y*y);
            float D_Coord = Dist2 / (2.0 * SigmaCoord * SigmaCoord);

            // B. 颜色权重 (Color Weight) - 颜色越相近，权重越大
            // 使用自适应 Sigma 修正
            float ColorDist2 = SqrDistance(CenterColor, NeighborColor);
            float D_Color = ColorDist2 / (2.0 * AdaptiveSigmaColor * AdaptiveSigmaColor);

            // [进阶: 萤火虫压制 (Firefly Suppression)]
            // 这是一个非标准的 Bilateral 扩展。
            // 逻辑：如果邻居比中心亮得多 (LumaNeighbor >> LumaCenter)，它极可能是一个噪点 (Firefly)。
            // 我们人为降低它的权重，防止它把周围像素都“带亮”。
            float LumaCenter = LuminanceDenoise(CenterColor);
            float LumaNeighbor = LuminanceDenoise(NeighborColor);
            // 分母加了 max(0, diff)，意味着邻居越亮，FireflyWeight 越小 (< 1.0)
            float FireflyWeight = 1.0 / (1.0 + max(0.0, LumaNeighbor - LumaCenter) / AdaptiveSigmaColor);

            // C. 法线权重 (Normal Weight) - 法线方向越一致，权重越大
            // 用于保护几何边缘 (Geometry Edges)
            float NormalAngle = SafeAcos(dot(CenterNormal, NeighborNormal));
            float D_Normal = (NormalAngle * NormalAngle) / (2.0 * SigmaNormal * SigmaNormal);

            // D. 平面/深度权重 (Depth/Plane Weight) - 深度越接近，权重越大
            // 用于防止背景模糊到前景上 (Halo Artifacts)
            float DepthDiff = abs(NeighborDepth - CenterDepth);
            float D_Plane = (DepthDiff * DepthDiff) / (2.0 * SigmaPlane * SigmaPlane);

            // 综合权重：所有权重的乘积 (在指数空间是相加)
            float Weight = exp(-(D_Plane + D_Coord + D_Color + D_Normal));
            
            // 应用萤火虫压制系数
            Weight *= FireflyWeight;

            // -----------------------------------------------------------------
            // 6. 累积
            // -----------------------------------------------------------------
            SumColor += NeighborColor * Weight;
            TotalWeight += Weight;
        }
    }

    // -------------------------------------------------------------------------
    // 7. 归一化输出
    // -------------------------------------------------------------------------
    if (TotalWeight > 0.0001)
    {
        SSGIDenoiseOutput[PixelPos] = float4(SumColor / TotalWeight, 1.0);
    }
    else
    {
        // 极端情况：所有邻居权重都极低 (几乎不可能发生)，退化为中心像素
        SSGIDenoiseOutput[PixelPos] = float4(CenterColor, 1.0);
    }
}