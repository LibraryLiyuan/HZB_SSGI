// SSGIDenoiser.usf
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"


Texture2D SSGIInputTexture;
Texture2D SceneDepthTexture; 
Texture2D GBufferATexture;


RWTexture2D<float4> SSGIDenoiseOutput;

float4 ViewSizeAndInvSize;
float4 BufferSizeAndInvSize;
float4 ViewRectMin;
float Intensity;

float3 GetWorldNormal(float2 BufferUV)
{
    float2 Oct = GBufferATexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).xy;
    Oct = Oct * 2.0 - 1.0;
    float3 N = float3(Oct, 1.0 - dot(1.0, abs(Oct)));
    if (N.z < 0)
    {
        float2 SignNotZero = float2(N.x >= 0 ? 1.0 : -1.0, N.y >= 0 ? 1.0 : -1.0);
        N.xy = (1.0 - abs(N.yx)) * SignNotZero;
    }
    return normalize(N);
}

float GetLinearDepth(float2 BufferUV)
{
    float DeviceZ = SceneDepthTexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).r;
    return ConvertFromDeviceZ(DeviceZ);
}

float SqrDistance(float3 A, float3 B)
{
    float3 Diff = A - B;
    return dot(Diff, Diff);
}

float SafeAcos(float x)
{
    return acos(clamp(x, -1.0, 1.0));
}

float LuminanceDenoise(float3 Color) { return dot(Color, float3(0.2126, 0.7152, 0.0722)); }

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void DenoiserCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    uint2 PixelPos = DispatchThreadID.xy;
    if (any(PixelPos >= uint2(ViewSizeAndInvSize.xy))) return;
    float2 LocalUV = (float2(PixelPos) + 0.5) * ViewSizeAndInvSize.zw;

    float2 GlobalPixelPos = float2(PixelPos) + ViewRectMin.xy;
    float2 GlobalUV = (GlobalPixelPos + 0.5) * BufferSizeAndInvSize.zw;

    float3 CenterColor = SSGIInputTexture.SampleLevel(GlobalPointClampedSampler, LocalUV, 0).rgb;
    float3 CenterNormal = GetWorldNormal(GlobalUV);
    float CenterDepth = GetLinearDepth(GlobalUV);
    
    float BaseSigmaColor = 0.8; 
    float AdaptiveSigmaColor = BaseSigmaColor * max(1.0, Intensity);
    
    float SigmaCoord = 32.0; 
    float SigmaNormal = 0.3; 
    float SigmaPlane = 10.0;

    float3 SumColor = 0;
    float TotalWeight = 0;

    const int Radius = 4; 

    for (int x = -Radius; x <= Radius; x++)
    {
        for (int y = -Radius; y <= Radius; y++)
        {
            float2 NeighborLocalUV = LocalUV + float2(x, y) * ViewSizeAndInvSize.zw;
            
            float2 NeighborGlobalUV = GlobalUV + float2(x, y) * BufferSizeAndInvSize.zw;

            if (any(NeighborLocalUV < 0.0) || any(NeighborLocalUV > 1.0)) continue;

            float3 NeighborColor = SSGIInputTexture.SampleLevel(GlobalPointClampedSampler, NeighborLocalUV, 0).rgb;
            
            float3 NeighborNormal = GetWorldNormal(NeighborGlobalUV);
            float NeighborDepth = GetLinearDepth(NeighborGlobalUV);

            float Dist2 = float(x*x + y*y);
            float D_Coord = Dist2 / (2.0 * SigmaCoord * SigmaCoord);

            float ColorDist2 = SqrDistance(CenterColor, NeighborColor);
            float D_Color = ColorDist2 / (2.0 * AdaptiveSigmaColor * AdaptiveSigmaColor);

            float LumaCenter = LuminanceDenoise(CenterColor);
            float LumaNeighbor = LuminanceDenoise(NeighborColor);
            float FireflyWeight = 1.0 / (1.0 + max(0.0, LumaNeighbor - LumaCenter) / AdaptiveSigmaColor);

            float NormalAngle = SafeAcos(dot(CenterNormal, NeighborNormal));
            float D_Normal = (NormalAngle * NormalAngle) / (2.0 * SigmaNormal * SigmaNormal);

            float DepthDiff = abs(NeighborDepth - CenterDepth);
            float D_Plane = (DepthDiff * DepthDiff) / (2.0 * SigmaPlane * SigmaPlane);

            float Weight = exp(-(D_Plane + D_Coord + D_Color + D_Normal));
            
            Weight *= FireflyWeight;

            SumColor += NeighborColor * Weight;
            TotalWeight += Weight;
        }
    }

    if (TotalWeight > 0.0001)
    {
        SSGIDenoiseOutput[PixelPos] = float4(SumColor / TotalWeight, 1.0);
    }
    else
    {
        SSGIDenoiseOutput[PixelPos] = float4(CenterColor, 1.0);
    }
}