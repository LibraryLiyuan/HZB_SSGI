// SSGITemporal.usf
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

Texture2D CurrentFrameTexture;
Texture2D HistoryTexture;
Texture2D VelocityTexture;
Texture2D SceneDepthTexture;

RWTexture2D<float4> OutputTexture;

float4 ViewSizeAndInvSize;
float4 BufferSizeAndInvSize;
float4 ViewRectMin;
float HistoryWeight;
SamplerState BilinearSampler;

float3 RGBToYCoCg(float3 RGB)
{
    float Y  = dot(RGB, float3( 0.25, 0.50,  0.25));
    float Co = dot(RGB, float3( 0.50, 0.00, -0.50));
    float Cg = dot(RGB, float3(-0.25, 0.50, -0.25));
    return float3(Y, Co, Cg);
}

float3 YCoCgToRGB(float3 YCoCg)
{
    float Y  = YCoCg.x;
    float Co = YCoCg.y;
    float Cg = YCoCg.z;
    float R = Y + Co - Cg;
    float G = Y + Cg;
    float B = Y - Co - Cg;
    return float3(R, G, B);
}

float3 Tonemap(float3 x) 
{ 
    float Luma = Luminance(x);
    return x / (1.0 + Luma); 
}

float3 InverseTonemap(float3 x) 
{ 
    float Luma = Luminance(x);
    return x / max(1e-4, 1.0 - Luma); 
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void TemporalCS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    uint2 PixelPos = DispatchThreadID.xy;
    if (any(PixelPos >= uint2(ViewSizeAndInvSize.xy))) return;

    float2 LocalUV = (float2(PixelPos) + 0.5) * ViewSizeAndInvSize.zw;
    float2 GlobalPixelPos = float2(PixelPos) + ViewRectMin.xy;
    float2 GlobalUV = (GlobalPixelPos + 0.5) * BufferSizeAndInvSize.zw;

    float4 CurrentSample = CurrentFrameTexture.SampleLevel(GlobalPointClampedSampler, LocalUV, 0);
    float3 CurrentColorRGB = CurrentSample.rgb;
    
    float4 VelocitySample = VelocityTexture.SampleLevel(GlobalPointClampedSampler, GlobalUV, 0);
    float2 Velocity = VelocitySample.xy;
    
    if (max(abs(Velocity.x), abs(Velocity.y)) > 0.1) Velocity = 0; 

    float2 PrevLocalUV = LocalUV - Velocity;


    bool bOffScreen = any(PrevLocalUV < 0.0) || any(PrevLocalUV > 1.0);

    float3 m1 = 0;
    float3 m2 = 0;
    
    const int KernelRadius = 2;
    float WeightSum = 0;

    for(int x = -KernelRadius; x <= KernelRadius; x++)
    {
        for(int y = -KernelRadius; y <= KernelRadius; y++)
        {
            float2 SampleUV = LocalUV + float2(x, y) * ViewSizeAndInvSize.zw;
            
            if(any(SampleUV < 0) || any(SampleUV > 1)) continue;

            float3 SampleRGB = CurrentFrameTexture.SampleLevel(GlobalPointClampedSampler, SampleUV, 0).rgb;
            
            float3 SampleTM = Tonemap(SampleRGB);
            float3 SampleYCoCg = RGBToYCoCg(SampleTM);
            
            m1 += SampleYCoCg;
            m2 += SampleYCoCg * SampleYCoCg;
            WeightSum += 1.0;
        }
    }

    float3 Mean = m1 / WeightSum;
    float3 Sigma = sqrt(abs(m2 / WeightSum - Mean * Mean));

    float Gamma = 2.0; 
    
    float3 MinYCoCg = Mean - Gamma * Sigma;
    float3 MaxYCoCg = Mean + Gamma * Sigma;

    float3 HistoryColorRGB = CurrentColorRGB;
    float HistoryAccumulationCount = 0.0;
    bool bHistoryValid = !bOffScreen;

    if (bHistoryValid)
    {
        float4 HistoryRead = HistoryTexture.SampleLevel(BilinearSampler, PrevLocalUV, 0);
        float3 RawHistoryRGB = HistoryRead.rgb;
        HistoryAccumulationCount = HistoryRead.a;

        float3 RawHistoryTM = Tonemap(RawHistoryRGB);
        float3 RawHistoryYCoCg = RGBToYCoCg(RawHistoryTM);
        
        float3 ClampedHistoryYCoCg = clamp(RawHistoryYCoCg, MinYCoCg, MaxYCoCg);
        
        float3 ClampedHistoryTM = YCoCgToRGB(ClampedHistoryYCoCg);
        HistoryColorRGB = InverseTonemap(ClampedHistoryTM);
    }

    if (!bHistoryValid)
    {
        HistoryAccumulationCount = 0.0;
    }

    float CurrentAccumulationCount = HistoryAccumulationCount + 1.0;
    float MaxAccumulation = 32.0;
    CurrentAccumulationCount = min(CurrentAccumulationCount, MaxAccumulation);

    float CurrentAlpha = 1.0 / CurrentAccumulationCount;

    float3 FinalColor = lerp(HistoryColorRGB, CurrentColorRGB, CurrentAlpha);
    
    FinalColor = max(FinalColor, 0.0);
    
    if (any(isnan(FinalColor)) || any(isinf(FinalColor)))
    {
        FinalColor = CurrentColorRGB;
    }

    OutputTexture[PixelPos] = float4(FinalColor, CurrentAccumulationCount);
}