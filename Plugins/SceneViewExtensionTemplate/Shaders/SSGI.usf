// [SSGI.usf]
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "RayTracingCommon.ush"

// [参数定义]
Texture2D HZBTexture;
Texture2D SceneColorTexture;
Texture2D InputSceneDepthTexture;

Texture2D SSGI_GBufferA;
Texture2D SSGI_GBufferB;
Texture2D SSGI_GBufferC;
Texture2D SSGI_GBufferD;
Texture2D SSGI_GBufferE;
Texture2D SSGI_GBufferF;
Texture2D SSGI_GBufferVelocity;

float4 HZBSize;
int MaxMipLevel;
int MaxIterations;
float Thickness;
float RayLength;
float Intensity;
int DebugMode;

RWTexture2D<float4> SSGI_Raw_Output;

static uint3 RandState;
void RandInit(uint2 PixelPos, uint FrameIndex, uint Seed)
{
    RandState.x = PixelPos.x * 49157 + PixelPos.y;
    RandState.y = FrameIndex * 389 + Seed;
    RandState.z = PixelPos.x ^ PixelPos.y ^ Seed;
}
float Rand()
{
    RandState.x = (RandState.x * 1664525 + 1013904223);
    RandState.y = (RandState.y * 1664525 + 1013904223);
    return float(RandState.x) / 4294967296.0;
}

float3 GetHeatmapColor(float Value)
{
    float3 Color = float3(0,0,1); // 0 = Blue
    if (Value > 0.25) Color = lerp(float3(0,0,1), float3(0,1,0), (Value - 0.25) * 4.0);
    if (Value > 0.5)  Color = lerp(float3(0,1,0), float3(1,1,0), (Value - 0.5) * 4.0);
    if (Value > 0.75) Color = lerp(float3(1,1,0), float3(1,0,0), (Value - 0.75) * 4.0);
    return Color;
}

float4 ManualViewRectMin;
float4 ManualViewSizeAndInvSize;
float4 ManualBufferSizeAndInvSize;
float4x4 ManualSVPositionToTranslatedWorld;
float4x4 ManualTranslatedWorldToClip;

float3 CustomOctahedralDecode(float2 Oct)
{
    Oct = Oct * 2.0 - 1.0;
    float3 N = float3(Oct, 1.0 - dot(1.0, abs(Oct)));
    if (N.z < 0)
    {
        float2 SignNotZero = float2(N.x >= 0 ? 1.0 : -1.0, N.y >= 0 ? 1.0 : -1.0);
        N.xy = (1.0 - abs(N.yx)) * SignNotZero;
    }
    return normalize(N);
}

struct FCustomGBufferData
{
    float3 WorldNormal;
    float Depth;
};

FCustomGBufferData GetGBufferDataCustom(float2 UV)
{
    FCustomGBufferData Out;
    Out.Depth = InputSceneDepthTexture.SampleLevel(GlobalPointClampedSampler, UV, 0).r;
    float4 GBufferA = SSGI_GBufferA.SampleLevel(GlobalPointClampedSampler, UV, 0);
    Out.WorldNormal = CustomOctahedralDecode(GBufferA.xy);
    return Out;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void SSGICS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    uint2 PixelPos = DispatchThreadID.xy;
    float2 ViewportSize = ManualViewSizeAndInvSize.xy;
    
    float2 ScreenPos = float2(PixelPos) + ManualViewRectMin.xy + 0.5;
    if (any(PixelPos >= uint2(ViewportSize))) return;

    float2 BufferUV = ScreenPos * ManualBufferSizeAndInvSize.zw;

    FCustomGBufferData GBuffer = GetGBufferDataCustom(BufferUV);
    float3 WorldNormal = GBuffer.WorldNormal;
    float DeviceDepth = GBuffer.Depth;

    if (length(WorldNormal) < 0.1) WorldNormal = float3(0, 0, 1);

    if (DebugMode != 7 && DeviceDepth <= 0.00001f) 
    {
        SSGI_Raw_Output[PixelPos] = 0;
        return;
    }

    // [删掉这行] 错误：不能直接把 PixelPos (ScreenPos) 传给逆投影矩阵
    // float4 SvPosition = float4(ScreenPos, DeviceDepth, 1.0);
    // float4 WorldPos4 = mul(SvPosition, ManualSVPositionToTranslatedWorld);

    // ================= [核心修复] 坐标系转换 =================
    // 我们的矩阵是 InvViewProjection，它期望输入是 Clip Space (NDC)
    // 范围：X [-1, 1], Y [1, -1] (UE Y轴向上为+1, UV向下为+1)
    
    float2 NDC;
    NDC.x = BufferUV.x * 2.0 - 1.0;       // 0..1 -> -1..1
    NDC.y = 1.0 - BufferUV.y * 2.0;       // 0..1 -> 1..-1 (翻转Y)

    float4 ClipPosition = float4(NDC, DeviceDepth, 1.0);
    float4 WorldPos4 = mul(ClipPosition, ManualSVPositionToTranslatedWorld);
    float3 WorldPos = WorldPos4.xyz / WorldPos4.w;

    float3 BiasedWorldPos = WorldPos + WorldNormal * 2.0;

    uint LinearIndex = PixelPos.y * ViewportSize.x + PixelPos.x;
    RandInit(LinearIndex, View.StateFrameIndexMod8, LinearIndex * 114);
    float2 RandE = float2(Rand(), Rand());
    
    float3 LocalRayDir = CosineSampleHemisphere(RandE).xyz;
    float3x3 TangentToWorld = GetTangentBasis(WorldNormal);
    float3 WorldRayDir = mul(LocalRayDir, TangentToWorld);
    float3 WorldRayEnd = BiasedWorldPos + WorldRayDir * RayLength;

    // 1. View Space Clipping (防止投射到相机背后)
    float4 ClipStart = mul(float4(BiasedWorldPos, 1.0), ManualTranslatedWorldToClip);
    float4 ClipEnd   = mul(float4(WorldRayEnd, 1.0), ManualTranslatedWorldToClip);
    
    float NearPlane = 0.1; 
    if (ClipEnd.w < NearPlane)
    {
        float t = (NearPlane - ClipStart.w) / (ClipEnd.w - ClipStart.w);
        t = clamp(t, 0.0, 0.999); 
        ClipEnd = lerp(ClipStart, ClipEnd, t);
    }
    
    if (ClipStart.w < 1e-4) 
    { 
        SSGI_Raw_Output[PixelPos] = 0;
        return; 
    }

    float3 ViewportStart = ClipStart.xyz / ClipStart.w;
    float3 ViewportEnd   = ClipEnd.xyz / ClipEnd.w;
    ViewportStart.xy = ViewportStart.xy * float2(0.5, -0.5) + 0.5;
    ViewportEnd.xy   = ViewportEnd.xy   * float2(0.5, -0.5) + 0.5;

    float2 UVScale = ManualViewSizeAndInvSize.xy * ManualBufferSizeAndInvSize.zw;
    float2 UVOffset = ManualViewRectMin.xy * ManualBufferSizeAndInvSize.zw;

    float3 BufferStart = ViewportStart;
    BufferStart.xy = ViewportStart.xy * UVScale + UVOffset;
    
    float3 BufferEnd = ViewportEnd;
    BufferEnd.xy = ViewportEnd.xy * UVScale + UVOffset;

    float3 ScreenRayDir = BufferEnd - BufferStart;

    // ================= [核心修复 2] 屏幕边缘裁剪 =================
    // 解决 Debug 3 为红色的问题：如果光线射出屏幕，强行截断在屏幕边缘
    // 这样 RayMarching 永远不会处理 > 1.0 的超长光线
    float t_max = 1.0;
    
    // X轴裁剪 (0~1)
    if (ScreenRayDir.x > 1e-6)       t_max = min(t_max, (1.0 - BufferStart.x) / ScreenRayDir.x);
    else if (ScreenRayDir.x < -1e-6) t_max = min(t_max, (0.0 - BufferStart.x) / ScreenRayDir.x);
    
    // Y轴裁剪 (0~1)
    if (ScreenRayDir.y > 1e-6)       t_max = min(t_max, (1.0 - BufferStart.y) / ScreenRayDir.y);
    else if (ScreenRayDir.y < -1e-6) t_max = min(t_max, (0.0 - BufferStart.y) / ScreenRayDir.y);
    
    // 应用裁剪
    ScreenRayDir *= t_max;
    // ========================================================

    FHiZTraceInput TraceInput;
    TraceInput.RayOrigin = BufferStart;
    TraceInput.RayDirection = ScreenRayDir; 
    TraceInput.HZBTexture = HZBTexture;
    TraceInput.HZBSize = HZBSize;
    TraceInput.MaxMipLevel = MaxMipLevel;
    
    // [强制保护] 确保迭代次数不为0
    TraceInput.MaxIterations = (MaxIterations <= 0) ? 64 : MaxIterations;
    
    TraceInput.Thickness = (Thickness < 0.1) ? 10.0 : Thickness; 
    
    FHiZTraceResult TraceResult = HiZTrace(TraceInput);

    // ================= [恢复原始 Debug 逻辑] =================
    if (DebugMode != 0)
    {
        float4 DebugColor = float4(0,0,0,1);

        if (DebugMode == 1) // [热力图]
        {
            // 如果还是一片蓝，说明 Iterations 真的很少
            // 如果看到红色/黄色，说明光线终于跑起来了！
            float Ratio = TraceResult.Iterations / float(TraceInput.MaxIterations);
            DebugColor.rgb = GetHeatmapColor(Ratio);
            if (TraceResult.bHit) DebugColor.rgb += 0.2; // 命中变亮
        }
        else if (DebugMode == 2) // [击中 UV]
        {
            if (TraceResult.bHit) DebugColor = float4(TraceResult.HitUVz.xy, 0, 1);
            else DebugColor = float4(0.2, 0.2, 0.2, 1); 
        }
        else if (DebugMode == 3) // [检查光线方向]
        {
            // 绿色 = 短光线, 黄色 = 长光线
            // 现在不应该看到纯红了，因为我们做了裁剪
            float Len = length(ScreenRayDir.xy);
            DebugColor = float4(Len, Len, 0, 1); 
        }
        else if (DebugMode == 4) DebugColor.rgb = HZBTexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).rrr;
        else if (DebugMode == 5) DebugColor.rgb = frac(WorldPos * 0.01);
        else if (DebugMode == 6) DebugColor.rgb = float3(ViewportStart.xy, 0);
        else if (DebugMode == 7) DebugColor.rgb = (DeviceDepth > 0.00001) ? float3(1, 0, 0) : 0;

        SSGI_Raw_Output[PixelPos] = DebugColor;
        return;
    }

    float4 OutColor = 0;
    if (TraceResult.bHit)
    {
        float2 HitBufferUV = TraceResult.HitUVz.xy;
        // 边界检查
        if (all(HitBufferUV >= 0.0) && all(HitBufferUV <= 1.0))
        {
            float3 HitColor = SceneColorTexture.SampleLevel(GlobalBilinearClampedSampler, HitBufferUV, 0).rgb;
            OutColor = float4(HitColor * Intensity, 1.0);
        }
    }
    SSGI_Raw_Output[PixelPos] = OutColor;
}