// SSGI.usf
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/MonteCarlo.ush"
#include "RayTracingCommon.ush"

// [Inputs]
Texture2D HZBTexture;
Texture2D SceneColorTexture;
Texture2D InputSceneDepthTexture;
// GBuffer的World Normal
Texture2D SSGI_GBufferA;

float4 HZBSize;
int MaxMipLevel;
int MaxIterations;
float Thickness;
float RayLength;
float Intensity;
//int DebugMode;
int FrameIndex;

float4 ViewRectMin;
float4 ViewSizeAndInvSize;
float4 BufferSizeAndInvSize;

float4x4 SVPositionToTranslatedWorld;
float4x4 TranslatedWorldToClip;

RWTexture2D<float4> SSGI_Raw_Output;

static uint3 RandState;

uint Hash(uint x)
{
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}
// 随机状态，引入FrameIndex，进行时间差异
void RandInit(uint2 PixelPos, uint FrameIndex, uint Seed)
{
    uint CombinedSeed = PixelPos.x + (PixelPos.y << 16);
    
    CombinedSeed = Hash(CombinedSeed ^ Hash(FrameIndex));
    CombinedSeed = Hash(CombinedSeed ^ Hash(Seed));

    RandState.x = CombinedSeed;
    RandState.y = Hash(CombinedSeed + 1);
    RandState.z = Hash(CombinedSeed + 2);
}

float Rand()
{
    RandState.x = (RandState.x * 1664525 + 1013904223);
    return float(RandState.x) / 4294967296.0;
}

float3 GetHeatmapColor(float Value)
{
    float3 Color = float3(0,0,1);
    if (Value > 0.25) Color = lerp(float3(0,0,1), float3(0,1,0), (Value - 0.25) * 4.0);
    if (Value > 0.5)  Color = lerp(float3(0,1,0), float3(1,1,0), (Value - 0.5) * 4.0);
    if (Value > 0.75) Color = lerp(float3(1,1,0), float3(1,0,0), (Value - 0.75) * 4.0);
    return Color;
}

// UE的GBuffer的深度只存了二维分量
// 八面体解码
float3 CustomOctahedralDecode(float2 Oct)
{
    Oct = Oct * 2.0 - 1.0;
    float3 N = float3(Oct, 1.0 - dot(1.0, abs(Oct)));
    if (N.z < 0)
    {
        float2 SignNotZero = float2(N.x >= 0 ? 1.0 : -1.0, N.y >= 0 ? 1.0 : -1.0);
        N.xy = (1.0 - abs(N.yx)) * SignNotZero;
    }
    return normalize(N);
}

struct FCustomGBufferData
{
    float3 WorldNormal;
    float Depth;
};

FCustomGBufferData GetGBufferDataCustom(float2 BufferUV)
{
    FCustomGBufferData Out;
    Out.Depth = InputSceneDepthTexture.SampleLevel(GlobalPointClampedSampler, BufferUV, 0).r;
    float4 GBufferA = SSGI_GBufferA.SampleLevel(GlobalPointClampedSampler, BufferUV, 0);
    Out.WorldNormal = CustomOctahedralDecode(GBufferA.xy);
    return Out;
}

[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void SSGICS(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    uint2 PixelPos = DispatchThreadID.xy;
    float2 ViewportSize = ViewSizeAndInvSize.xy;
    float2 ScreenPos = float2(PixelPos) + ViewRectMin.xy + 0.5;
    
    if (any(PixelPos >= uint2(ViewportSize))) return;

    float2 BufferUV = ScreenPos * BufferSizeAndInvSize.zw;
    
    FCustomGBufferData GBuffer = GetGBufferDataCustom(BufferUV);
    float3 WorldNormal = GBuffer.WorldNormal;
    float DeviceDepth = GBuffer.Depth;

    if (length(WorldNormal) < 0.1) WorldNormal = float3(0, 0, 1);
    
    if (DeviceDepth <= 0.00001f) 
    {
        SSGI_Raw_Output[PixelPos] = 0;
        return;
    }
    
    float2 ViewUV = (float2(PixelPos) + 0.5) * ViewSizeAndInvSize.zw;
    
    float2 NDC;
    NDC.x = ViewUV.x * 2.0 - 1.0;
    NDC.y = 1.0 - ViewUV.y * 2.0;

    float4 ClipPosition = float4(NDC, DeviceDepth, 1.0);
    float4 WorldPos4 = mul(ClipPosition, SVPositionToTranslatedWorld);
    float3 WorldPos = WorldPos4.xyz / WorldPos4.w;
    float3 BiasedWorldPos = WorldPos + WorldNormal * 2.0;
    
    int NumSamples = 1; 
    
    float3 AccumulatedColor = 0;
    float ValidSamples = 0;

    float2 ValidUVMin;
    float2 ValidUVMax;
    
    for (int i = 0; i < NumSamples; i++)
    {
        RandInit(PixelPos, FrameIndex, i);
        float2 RandE = float2(Rand(), Rand());
        // 生成光线，余弦加权采样
        // sqrt(RanE.y)
        float3 LocalRayDir = CosineSampleHemisphere(RandE).xyz;
        // 光线：像素局部空间->世界空间->屏幕空间
        // TBN 矩阵
        float3x3 TangentToWorld = GetTangentBasis(WorldNormal);
        float3 WorldRayDir = mul(LocalRayDir, TangentToWorld);
        float3 WorldRayEnd = BiasedWorldPos + WorldRayDir * RayLength;

        float4 ClipStart = mul(float4(BiasedWorldPos, 1.0), TranslatedWorldToClip);
        float4 ClipEnd   = mul(float4(WorldRayEnd, 1.0), TranslatedWorldToClip);
        
        float NearPlane = 0.1;
        if (ClipEnd.w < NearPlane)
        {
            float t = (NearPlane - ClipStart.w) / (ClipEnd.w - ClipStart.w);
            t = clamp(t, 0.0, 0.999); 
            ClipEnd = lerp(ClipStart, ClipEnd, t);
        }
        
        if (ClipStart.w < 1e-4) continue;

        // 使用Buffer尺寸生成光线，然后使用View进行边界检测
        // 透视除法
        float3 ViewportStart = ClipStart.xyz / ClipStart.w;
        float3 ViewportEnd   = ClipEnd.xyz / ClipEnd.w;
        ViewportStart.xy = ViewportStart.xy * float2(0.5, -0.5) + 0.5;
        ViewportEnd.xy   = ViewportEnd.xy   * float2(0.5, -0.5) + 0.5;
        // View到Buffer的尺寸变换
        float2 UVScale = ViewSizeAndInvSize.xy * BufferSizeAndInvSize.zw;
        float2 UVOffset = ViewRectMin.xy * BufferSizeAndInvSize.zw;

        float3 BufferStart = ViewportStart;
        BufferStart.xy = ViewportStart.xy * UVScale + UVOffset;
        float3 BufferEnd = ViewportEnd;
        BufferEnd.xy = ViewportEnd.xy * UVScale + UVOffset;
        float3 ScreenRayDir = BufferEnd - BufferStart;

        ValidUVMin = UVOffset;
        ValidUVMax = UVOffset + UVScale;

        float t_max = 1.0;
        if (ScreenRayDir.x > 1e-6)       t_max = min(t_max, (ValidUVMax.x - BufferStart.x) / ScreenRayDir.x);
        else if (ScreenRayDir.x < -1e-6) t_max = min(t_max, (ValidUVMin.x - BufferStart.x) / ScreenRayDir.x);
        if (ScreenRayDir.y > 1e-6)       t_max = min(t_max, (ValidUVMax.y - BufferStart.y) / ScreenRayDir.y);
        else if (ScreenRayDir.y < -1e-6) t_max = min(t_max, (ValidUVMin.y - BufferStart.y) / ScreenRayDir.y);
        ScreenRayDir *= t_max;

        // 执行追踪
        FHiZTraceInput TraceInput;
        TraceInput.RayOrigin = BufferStart;
        TraceInput.RayDirection = ScreenRayDir; 
        TraceInput.HZBTexture = HZBTexture;
        TraceInput.HZBSize = HZBSize;
        TraceInput.MaxMipLevel = MaxMipLevel;
        TraceInput.MaxIterations = (MaxIterations <= 0) ? 64 : MaxIterations;
        TraceInput.Thickness = (Thickness < 0.1) ? 10.0 : Thickness; 
        TraceInput.ValidUVMin = ValidUVMin;
        TraceInput.ValidUVMax = ValidUVMax;
        
        FHiZTraceResult TraceResult = HiZTrace(TraceInput);

        if (TraceResult.bHit)
        {
            float2 HitBufferUV = TraceResult.HitUVz.xy;
            if (all(HitBufferUV >= 0.0) && all(HitBufferUV <= 1.0))
            {
                float3 HitColor = SceneColorTexture.SampleLevel(GlobalBilinearClampedSampler, HitBufferUV, 0).rgb;
                float MaxBrightness = 10.0;
                float Luma = dot(HitColor, float3(0.2126, 0.7152, 0.0722));
                if (Luma > MaxBrightness)
                {
                    HitColor *= (MaxBrightness / Luma);
                }
                AccumulatedColor += HitColor;
                ValidSamples += 1.0;
            }
        }
    }
    float3 FinalColor = (ValidSamples > 0.0) ? (AccumulatedColor / float(NumSamples)) : float3(0,0,0);
    
    SSGI_Raw_Output[PixelPos] = float4(FinalColor * Intensity, 1.0);
}