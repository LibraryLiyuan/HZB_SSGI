// RayTracingCommon.ush
#pragma once
#include "/Engine/Private/Common.ush"

struct FHiZTraceInput
{
	float3 RayOrigin;
	float3 RayDirection;

	Texture2D HZBTexture;
	float4 HZBSize; 

	int MaxMipLevel;
	int MaxIterations;
	float Thickness;

	float2 ValidUVMin;
	float2 ValidUVMax;
};

struct FHiZTraceResult
{
	bool bHit;
	float3 HitUVz;
	float Iterations;
};

float2 GetCellCount(int MipLevel, float4 RootSize)
{
	return floor(RootSize.xy * exp2(-MipLevel));
}

FHiZTraceResult HiZTrace(FHiZTraceInput Input)
{
	FHiZTraceResult Result;
	Result.bHit = false;
	Result.HitUVz = float3(0, 0, 0);
	Result.Iterations = 0;

	float3 CurrentPos = Input.RayOrigin;
	float3 RayDir = Input.RayDirection;

	float3 InvRayDir;
	InvRayDir.x = (abs(RayDir.x) < 1e-6) ? 1e6 : 1.0 / RayDir.x;
	InvRayDir.y = (abs(RayDir.y) < 1e-6) ? 1e6 : 1.0 / RayDir.y;
	InvRayDir.z = (abs(RayDir.z) < 1e-6) ? 1e6 : 1.0 / RayDir.z;

	int CurrentMip = 0;
	float Iterations = 0;

	while (CurrentMip >= 0 && CurrentMip <= Input.MaxMipLevel && Iterations < Input.MaxIterations)
	{
		Iterations++;

		float2 CellCount = GetCellCount(CurrentMip, Input.HZBSize);
		float2 CellSize = 1.0 / CellCount;
		float2 CellUV = (floor(CurrentPos.xy * CellCount) + 0.5) * CellSize;
		
		float HZB_DeviceZ = Input.HZBTexture.SampleLevel(GlobalPointClampedSampler, CellUV, CurrentMip).r;
		const float DepthEpsilon = 0.0001;

		if (CurrentPos.z < HZB_DeviceZ + DepthEpsilon) 
		{
			if (CurrentMip == 0)
			{
				float Linear_HZB = ConvertFromDeviceZ(HZB_DeviceZ);
				float Linear_Ray = ConvertFromDeviceZ(CurrentPos.z);
				float DistDiff = Linear_Ray - Linear_HZB;

				if (DistDiff > 0.0 && DistDiff < Input.Thickness)
				{
					Result.bHit = true;
					Result.HitUVz = float3(CurrentPos.xy, HZB_DeviceZ); 
					Result.Iterations = Iterations;
					return Result;
				}
				else
				{
					Result.bHit = false;
				}
			}
			else
			{
				CurrentMip--;
				continue;
			}
		}

		{
			float2 CurrentCellIdx = floor(CurrentPos.xy * CellCount);
			float2 BoundaryUV = (CurrentCellIdx + float2(RayDir.x > 0 ? 1.0 : 0.0, RayDir.y > 0 ? 1.0 : 0.0)) * CellSize;
			float2 T_Boundary = (BoundaryUV - CurrentPos.xy) * InvRayDir.xy;
			float StepT = min(T_Boundary.x, T_Boundary.y) + 0.0001;

			CurrentPos += RayDir * StepT;
			CurrentMip = min(CurrentMip + 1, Input.MaxMipLevel);
		}

		if (any(CurrentPos.xy < Input.ValidUVMin) || any(CurrentPos.xy > Input.ValidUVMax) || CurrentPos.z < 0.0001)
		{
			break;
		}
	}

	Result.Iterations = Iterations;
	return Result;
}